// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BulkSubscribersResponse,
    BulkSubscribersResponseFromJSON,
    BulkSubscribersResponseToJSON,
    ConnectedWalletsResponse,
    ConnectedWalletsResponseFromJSON,
    ConnectedWalletsResponseToJSON,
    FavoritesResponse,
    FavoritesResponseFromJSON,
    FavoritesResponseToJSON,
    FollowersResponse,
    FollowersResponseFromJSON,
    FollowersResponseToJSON,
    FollowingResponse,
    FollowingResponseFromJSON,
    FollowingResponseToJSON,
    GetSupporter,
    GetSupporterFromJSON,
    GetSupporterToJSON,
    GetSupporters,
    GetSupportersFromJSON,
    GetSupportersToJSON,
    GetSupporting,
    GetSupportingFromJSON,
    GetSupportingToJSON,
    HistoryResponse,
    HistoryResponseFromJSON,
    HistoryResponseToJSON,
    RelatedArtistResponse,
    RelatedArtistResponseFromJSON,
    RelatedArtistResponseToJSON,
    Reposts,
    RepostsFromJSON,
    RepostsToJSON,
    SubscribersResponse,
    SubscribersResponseFromJSON,
    SubscribersResponseToJSON,
    TagsResponse,
    TagsResponseFromJSON,
    TagsResponseToJSON,
    TopGenreUsersResponse,
    TopGenreUsersResponseFromJSON,
    TopGenreUsersResponseToJSON,
    TopUsersResponse,
    TopUsersResponseFromJSON,
    TopUsersResponseToJSON,
    TracksResponse,
    TracksResponseFromJSON,
    TracksResponseToJSON,
    UserAssociatedWalletResponse,
    UserAssociatedWalletResponseFromJSON,
    UserAssociatedWalletResponseToJSON,
    UserResponse,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserSearch,
    UserSearchFromJSON,
    UserSearchToJSON,
    UserTrackListenCountsResponse,
    UserTrackListenCountsResponseFromJSON,
    UserTrackListenCountsResponseToJSON,
    UsersByContentNode,
    UsersByContentNodeFromJSON,
    UsersByContentNodeToJSON,
    VerifyToken,
    VerifyTokenFromJSON,
    VerifyTokenToJSON,
} from '../models';

export interface BulkGetSubscribersRequest {
    /**
     * User IDs to fetch subscribers for
     */
    ids: Array<string>;
}

export interface BulkGetSubscribersViaJSONRequestRequest {
    /**
     * User IDs to fetch subscribers for
     */
    ids: Array<string>;
}

export interface GetConnectedWalletsRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetFavoriteAlbumsRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetFavoritePlaylistsRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetFavoritesRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetFollowersRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetFollowingsRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetRelatedUsersRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetRepostsRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetRepostsByHandleRequest {
    /**
     * A User handle
     */
    handle: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetSubscribersRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetSupporterRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * A User ID of a supporter
     */
    supporterUserId: string;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetSupportersRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
}

export interface GetSupportingRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * A User ID of a supported user
     */
    supportedUserId: string;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetSupportingsRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
}

export interface GetTopTrackTagsRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetTopUsersRequest {
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetTopUsersInGenreRequest {
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * List of Genres
     */
    genre?: Array<string>;
}

export interface GetTracksByUserRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
    /**
     * [Deprecated] Field to sort by
     */
    sort?: GetTracksByUserSortEnum;
    /**
     * The filter query
     */
    query?: string;
    /**
     * The sort method
     */
    sortMethod?: GetTracksByUserSortMethodEnum;
    /**
     * The sort direction
     */
    sortDirection?: GetTracksByUserSortDirectionEnum;
    /**
     * Filter by unlisted or public tracks
     */
    filterTracks?: GetTracksByUserFilterTracksEnum;
}

export interface GetTracksByUserHandleRequest {
    /**
     * A User handle
     */
    handle: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
    /**
     * [Deprecated] Field to sort by
     */
    sort?: GetTracksByUserHandleSortEnum;
    /**
     * The filter query
     */
    query?: string;
    /**
     * The sort method
     */
    sortMethod?: GetTracksByUserHandleSortMethodEnum;
    /**
     * The sort direction
     */
    sortDirection?: GetTracksByUserHandleSortDirectionEnum;
    /**
     * Filter by unlisted or public tracks
     */
    filterTracks?: GetTracksByUserHandleFilterTracksEnum;
}

export interface GetUserRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetUserByHandleRequest {
    /**
     * A User handle
     */
    handle: string;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetUserIDFromWalletRequest {
    /**
     * Wallet address
     */
    associatedWallet: string;
}

export interface GetUserMonthlyTrackListensRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * Start time from which to start results for user listen count data (inclusive).
     */
    startTime: string;
    /**
     * End time until which to cut off results of listen count data (not inclusive).
     */
    endTime: string;
}

export interface GetUserReplicaSetRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetUsersTrackHistoryRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
    /**
     * The filter query
     */
    query?: string;
    /**
     * The sort method
     */
    sortMethod?: GetUsersTrackHistorySortMethodEnum;
    /**
     * The sort direction
     */
    sortDirection?: GetUsersTrackHistorySortDirectionEnum;
}

export interface SearchUsersRequest {
    /**
     * The search query
     */
    query: string;
}

export interface VerifyIDTokenRequest {
    /**
     * JWT to verify
     */
    token: string;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * All users that subscribe to the provided users
     */
    async bulkGetSubscribers(requestParameters: BulkGetSubscribersRequest): Promise<NonNullable<BulkSubscribersResponse["data"]>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling bulkGetSubscribers.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/subscribers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<BulkSubscribersResponse["data"]>>;
    }

    /**
     * Get all users that subscribe to the users listed in the JSON request
     */
    async bulkGetSubscribersViaJSONRequest(requestParameters: BulkGetSubscribersViaJSONRequestRequest): Promise<NonNullable<BulkSubscribersResponse["data"]>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/subscribers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<BulkSubscribersResponse["data"]>>;
    }

    /**
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWallets(requestParameters: GetConnectedWalletsRequest): Promise<NonNullable<ConnectedWalletsResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getConnectedWallets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/connected_wallets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<ConnectedWalletsResponse["data"]>>;
    }

    /**
     * Gets a user\'s favorite albums
     */
    async getFavoriteAlbums(requestParameters: GetFavoriteAlbumsRequest): Promise<NonNullable<FavoritesResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFavoriteAlbums.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/favorites/albums`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<FavoritesResponse["data"]>>;
    }

    /**
     * Gets a user\'s favorite playlists
     */
    async getFavoritePlaylists(requestParameters: GetFavoritePlaylistsRequest): Promise<NonNullable<FavoritesResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFavoritePlaylists.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/favorites/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<FavoritesResponse["data"]>>;
    }

    /**
     * Gets a user\'s favorite tracks
     */
    async getFavorites(requestParameters: GetFavoritesRequest): Promise<NonNullable<FavoritesResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFavorites.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/favorites`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<FavoritesResponse["data"]>>;
    }

    /**
     * All users that follow the provided user
     */
    async getFollowers(requestParameters: GetFollowersRequest): Promise<NonNullable<FollowersResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFollowers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<FollowersResponse["data"]>>;
    }

    /**
     * All users that the provided user follows
     */
    async getFollowings(requestParameters: GetFollowingsRequest): Promise<NonNullable<FollowingResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFollowings.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<FollowingResponse["data"]>>;
    }

    /**
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsers(requestParameters: GetRelatedUsersRequest): Promise<NonNullable<RelatedArtistResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRelatedUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<RelatedArtistResponse["data"]>>;
    }

    /**
     * Gets the given user\'s reposts
     */
    async getReposts(requestParameters: GetRepostsRequest): Promise<NonNullable<Reposts["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getReposts.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<Reposts["data"]>>;
    }

    /**
     * Gets the user\'s reposts by the user handle
     */
    async getRepostsByHandle(requestParameters: GetRepostsByHandleRequest): Promise<NonNullable<Reposts["data"]>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getRepostsByHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/handle/{handle}/reposts`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<Reposts["data"]>>;
    }

    /**
     * All users that subscribe to the provided user
     */
    async getSubscribers(requestParameters: GetSubscribersRequest): Promise<NonNullable<SubscribersResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSubscribers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<SubscribersResponse["data"]>>;
    }

    /**
     * Gets the specified supporter of the given user
     */
    async getSupporter(requestParameters: GetSupporterRequest): Promise<NonNullable<GetSupporter["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporter.');
        }

        if (requestParameters.supporterUserId === null || requestParameters.supporterUserId === undefined) {
            throw new runtime.RequiredError('supporterUserId','Required parameter requestParameters.supporterUserId was null or undefined when calling getSupporter.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/supporters/{supporter_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"supporter_user_id"}}`, encodeURIComponent(String(requestParameters.supporterUserId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<GetSupporter["data"]>>;
    }

    /**
     * Gets the supporters of the given user
     */
    async getSupporters(requestParameters: GetSupportersRequest): Promise<NonNullable<GetSupporters["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporters.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<GetSupporters["data"]>>;
    }

    /**
     * Gets the support from the given user to the supported user
     */
    async getSupporting(requestParameters: GetSupportingRequest): Promise<NonNullable<GetSupporting["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporting.');
        }

        if (requestParameters.supportedUserId === null || requestParameters.supportedUserId === undefined) {
            throw new runtime.RequiredError('supportedUserId','Required parameter requestParameters.supportedUserId was null or undefined when calling getSupporting.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/supporting/{supported_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"supported_user_id"}}`, encodeURIComponent(String(requestParameters.supportedUserId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<GetSupporting["data"]>>;
    }

    /**
     * Gets the users that the given user supports
     */
    async getSupportings(requestParameters: GetSupportingsRequest): Promise<NonNullable<GetSupporting["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupportings.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<GetSupporting["data"]>>;
    }

    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTags(requestParameters: GetTopTrackTagsRequest): Promise<NonNullable<TagsResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTopTrackTags.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/tags`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TagsResponse["data"]>>;
    }

    /**
     * Get the Top Users having at least one track by follower count
     */
    async getTopUsers(requestParameters: GetTopUsersRequest = {}): Promise<NonNullable<TopUsersResponse["data"]>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/top`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TopUsersResponse["data"]>>;
    }

    /**
     * Get the Top Users for a Given Genre
     */
    async getTopUsersInGenre(requestParameters: GetTopUsersInGenreRequest = {}): Promise<NonNullable<TopGenreUsersResponse["data"]>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.genre) {
            queryParameters['genre'] = requestParameters.genre;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/genre/top`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TopGenreUsersResponse["data"]>>;
    }

    /**
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUser(requestParameters: GetTracksByUserRequest): Promise<NonNullable<TracksResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTracksByUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = requestParameters.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TracksResponse["data"]>>;
    }

    /**
     * Gets the tracks created by a user using the user\'s handle
     */
    async getTracksByUserHandle(requestParameters: GetTracksByUserHandleRequest): Promise<NonNullable<TracksResponse["data"]>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = requestParameters.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/handle/{handle}/tracks`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TracksResponse["data"]>>;
    }

    /**
     * Gets a single user by their user ID
     */
    async getUser(requestParameters: GetUserRequest): Promise<NonNullable<UserResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserResponse["data"]>>;
    }

    /**
     * Gets a single user by their handle
     */
    async getUserByHandle(requestParameters: GetUserByHandleRequest): Promise<NonNullable<UserResponse["data"]>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getUserByHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserResponse["data"]>>;
    }

    /**
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWallet(requestParameters: GetUserIDFromWalletRequest): Promise<NonNullable<UserAssociatedWalletResponse["data"]>> {
        if (requestParameters.associatedWallet === null || requestParameters.associatedWallet === undefined) {
            throw new runtime.RequiredError('associatedWallet','Required parameter requestParameters.associatedWallet was null or undefined when calling getUserIDFromWallet.');
        }

        const queryParameters: any = {};

        if (requestParameters.associatedWallet !== undefined) {
            queryParameters['associated_wallet'] = requestParameters.associatedWallet;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/id`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserAssociatedWalletResponse["data"]>>;
    }

    /**
     * Gets the listen data for a user by month and track within a given time frame.
     */
    async getUserMonthlyTrackListens(requestParameters: GetUserMonthlyTrackListensRequest): Promise<NonNullable<UserTrackListenCountsResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUserMonthlyTrackListens.');
        }

        if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
            throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling getUserMonthlyTrackListens.');
        }

        if (requestParameters.endTime === null || requestParameters.endTime === undefined) {
            throw new runtime.RequiredError('endTime','Required parameter requestParameters.endTime was null or undefined when calling getUserMonthlyTrackListens.');
        }

        const queryParameters: any = {};

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = requestParameters.startTime;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = requestParameters.endTime;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/listen_counts_monthly`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserTrackListenCountsResponse["data"]>>;
    }

    /**
     * Gets the user\'s replica set
     */
    async getUserReplicaSet(requestParameters: GetUserReplicaSetRequest): Promise<NonNullable<UsersByContentNode["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUserReplicaSet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/replica_set`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UsersByContentNode["data"]>>;
    }

    /**
     * Get the tracks the user recently listened to.
     */
    async getUsersTrackHistory(requestParameters: GetUsersTrackHistoryRequest): Promise<NonNullable<HistoryResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUsersTrackHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/history/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<HistoryResponse["data"]>>;
    }

    /**
     * Search for users that match the given query
     */
    async searchUsers(requestParameters: SearchUsersRequest): Promise<NonNullable<UserSearch["data"]>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling searchUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserSearch["data"]>>;
    }

    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDToken(requestParameters: VerifyIDTokenRequest): Promise<NonNullable<VerifyToken["data"]>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling verifyIDToken.');
        }

        const queryParameters: any = {};

        if (requestParameters.token !== undefined) {
            queryParameters['token'] = requestParameters.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/verify_token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<VerifyToken["data"]>>;
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserSortEnum {
    Date = 'date',
    Plays = 'plays'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserSortMethodEnum {
    Title = 'title',
    ArtistName = 'artist_name',
    ReleaseDate = 'release_date',
    LastListenDate = 'last_listen_date',
    AddedDate = 'added_date',
    Length = 'length',
    Plays = 'plays',
    Reposts = 'reposts',
    Saves = 'saves'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserSortDirectionEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserFilterTracksEnum {
    All = 'all',
    Public = 'public',
    Unlisted = 'unlisted'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserHandleSortEnum {
    Date = 'date',
    Plays = 'plays'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserHandleSortMethodEnum {
    Title = 'title',
    ArtistName = 'artist_name',
    ReleaseDate = 'release_date',
    LastListenDate = 'last_listen_date',
    AddedDate = 'added_date',
    Length = 'length',
    Plays = 'plays',
    Reposts = 'reposts',
    Saves = 'saves'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserHandleSortDirectionEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserHandleFilterTracksEnum {
    All = 'all',
    Public = 'public',
    Unlisted = 'unlisted'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUsersTrackHistorySortMethodEnum {
    Title = 'title',
    ArtistName = 'artist_name',
    ReleaseDate = 'release_date',
    LastListenDate = 'last_listen_date',
    AddedDate = 'added_date',
    Length = 'length',
    Plays = 'plays',
    Reposts = 'reposts',
    Saves = 'saves'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUsersTrackHistorySortDirectionEnum {
    Asc = 'asc',
    Desc = 'desc'
}
