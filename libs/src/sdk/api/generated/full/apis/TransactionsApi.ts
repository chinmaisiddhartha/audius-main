// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    TransactionHistoryCountResponse,
    TransactionHistoryCountResponseFromJSON,
    TransactionHistoryCountResponseToJSON,
    TransactionHistoryResponse,
    TransactionHistoryResponseFromJSON,
    TransactionHistoryResponseToJSON,
} from '../models';

export interface GetAudioTransactionHistoryRequest {
    /**
     * The data that was signed by the user for signature recovery
     */
    encodedDataMessage: string;
    /**
     * The signature of data, used for signature recovery
     */
    encodedDataSignature: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The sort method
     */
    sortMethod?: GetAudioTransactionHistorySortMethodEnum;
    /**
     * The sort direction
     */
    sortDirection?: GetAudioTransactionHistorySortDirectionEnum;
}

export interface GetAudioTransactionHistoryCountRequest {
    /**
     * The data that was signed by the user for signature recovery
     */
    encodedDataMessage: string;
    /**
     * The signature of data, used for signature recovery
     */
    encodedDataSignature: string;
}

/**
 * 
 */
export class TransactionsApi extends runtime.BaseAPI {

    /**
     * Gets the user\'s $AUDIO transaction history within the App
     */
    async getAudioTransactionHistory(requestParameters: GetAudioTransactionHistoryRequest): Promise<NonNullable<TransactionHistoryResponse["data"]>> {
        if (requestParameters.encodedDataMessage === null || requestParameters.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter requestParameters.encodedDataMessage was null or undefined when calling getAudioTransactionHistory.');
        }

        if (requestParameters.encodedDataSignature === null || requestParameters.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter requestParameters.encodedDataSignature was null or undefined when calling getAudioTransactionHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.encodedDataMessage !== undefined && requestParameters.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(requestParameters.encodedDataMessage);
        }

        if (requestParameters.encodedDataSignature !== undefined && requestParameters.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(requestParameters.encodedDataSignature);
        }

        return this.request({
            path: `/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TransactionHistoryResponse["data"]>>;
    }

    /**
     * Gets the count of the user\'s $AUDIO transaction history within the App
     */
    async getAudioTransactionHistoryCount(requestParameters: GetAudioTransactionHistoryCountRequest): Promise<NonNullable<TransactionHistoryCountResponse["data"]>> {
        if (requestParameters.encodedDataMessage === null || requestParameters.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter requestParameters.encodedDataMessage was null or undefined when calling getAudioTransactionHistoryCount.');
        }

        if (requestParameters.encodedDataSignature === null || requestParameters.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter requestParameters.encodedDataSignature was null or undefined when calling getAudioTransactionHistoryCount.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.encodedDataMessage !== undefined && requestParameters.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(requestParameters.encodedDataMessage);
        }

        if (requestParameters.encodedDataSignature !== undefined && requestParameters.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(requestParameters.encodedDataSignature);
        }

        return this.request({
            path: `/transactions/count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TransactionHistoryCountResponse["data"]>>;
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetAudioTransactionHistorySortMethodEnum {
    Date = 'date',
    TransactionType = 'transaction_type'
}
/**
    * @export
    * @enum {string}
    */
export enum GetAudioTransactionHistorySortDirectionEnum {
    Asc = 'asc',
    Desc = 'desc'
}
